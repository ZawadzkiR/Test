import json
import uuid
import time
import requests
import websocket  # pip install websocket-client

HUB = "https://twoj-hub.example.com"
USER = "jan"
TOKEN = "PASTE_TOKEN_HERE"

# 1) Start serwera użytkownika (JupyterHub REST)
r = requests.post(
    f"{HUB}/hub/api/users/{USER}/server",
    headers={"Authorization": f"token {TOKEN}"},
)
# 201/202/409 są typowe (409 = już działa)
if r.status_code not in (201, 202, 409):
    raise RuntimeError(f"Start server failed: {r.status_code} {r.text}")

# 2) Poczekaj aż single-user server zacznie odpowiadać
USER_BASE = f"{HUB}/user/{USER}"
for _ in range(60):
    try:
        rr = requests.get(f"{USER_BASE}/api", params={"token": TOKEN}, timeout=2)
        if rr.status_code == 200:
            break
    except requests.RequestException:
        pass
    time.sleep(1)
else:
    raise RuntimeError("User server not ready")

# 3) Utwórz kernel (Jupyter Server REST)
kr = requests.post(f"{USER_BASE}/api/kernels", params={"token": TOKEN})
kr.raise_for_status()
kernel_id = kr.json()["id"]
print("kernel:", kernel_id)

# 4) Połącz się WebSocketem do kanałów kernela i wyślij execute_request
ws_url = f"{USER_BASE.replace('https://','wss://').replace('http://','ws://')}/api/kernels/{kernel_id}/channels?token={TOKEN}"
ws = websocket.create_connection(ws_url)

msg_id = uuid.uuid4().hex
execute = {
    "header": {
        "msg_id": msg_id,
        "username": USER,
        "session": uuid.uuid4().hex,
        "msg_type": "execute_request",
        "version": "5.3",
    },
    "parent_header": {},
    "metadata": {},
    "content": {
        "code": "print('xd')",
        "silent": False,
        "store_history": True,
        "user_expressions": {},
        "allow_stdin": False,
        "stop_on_error": True,
    },
    "channel": "shell",
    "buffers": [],
}

ws.send(json.dumps(execute))

# 5) Odbierz output z iopub (szukamy stream/text i execute_reply)
got_reply = False
while True:
    raw = ws.recv()
    m = json.loads(raw)

    msg_type = m.get("header", {}).get("msg_type")
    channel = m.get("channel")

    if channel == "iopub" and msg_type == "stream":
        print(m["content"].get("text", ""), end="")   # powinno wypisać: xd

    if channel == "shell" and msg_type == "execute_reply":
        got_reply = True

    if got_reply and channel == "iopub" and msg_type == "status" and m["content"].get("execution_state") == "idle":
        break

ws.close()

# (opcjonalnie) stop kernela:
requests.delete(f"{USER_BASE}/api/kernels/{kernel_id}", params={"token": TOKEN})
