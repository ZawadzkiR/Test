import os
import ast
import nbformat
from pkg_resources import get_distribution, DistributionNotFound

def find_imports_in_py(file_path):
    """Funkcja do znajdowania importów w plikach .py."""
    imports = set()
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read())
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.add(alias.name.split('.')[0])
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.add(node.module.split('.')[0])
    except Exception as e:
        print(f"Błąd podczas przetwarzania pliku {file_path}: {e}")
    return imports

def find_imports_in_ipynb(file_path):
    """Funkcja do znajdowania importów w plikach .ipynb."""
    imports = set()
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            notebook = nbformat.read(f, as_version=4)
            for cell in notebook.get("cells", []):
                if cell["cell_type"] == "code":
                    try:
                        tree = ast.parse(cell["source"])
                        for node in ast.walk(tree):
                            if isinstance(node, ast.Import):
                                for alias in node.names:
                                    imports.add(alias.name.split('.')[0])
                            elif isinstance(node, ast.ImportFrom):
                                if node.module:
                                    imports.add(node.module.split('.')[0])
                    except SyntaxError:
                        print(f"Błąd składni w komórce kodu w pliku: {file_path}")
    except Exception as e:
        print(f"Błąd podczas przetwarzania pliku {file_path}: {e}")
    return imports

def find_imports_in_folder(folder_path):
    """Funkcja do przeszukiwania folderu w poszukiwaniu importów w plikach .py i .ipynb."""
    all_imports = set()
    for root, _, files in os.walk(folder_path):
        for file in files:
            file_path = os.path.join(root, file)
            if file.endswith(".py"):
                all_imports.update(find_imports_in_py(file_path))
            elif file.endswith(".ipynb"):
                all_imports.update(find_imports_in_ipynb(file_path))
    return all_imports

def get_library_versions(libraries):
    """Pobiera wersje bibliotek zainstalowanych w środowisku."""
    lib_with_versions = {}
    for library in libraries:
        try:
            version = get_distribution(library).version
            lib_with_versions[library] = version
        except DistributionNotFound:
            lib_with_versions[library] = None  # Biblioteka nie jest zainstalowana
    return lib_with_versions

# Konfiguracja
folder_path = "."  # Zmień na swoją ścieżkę
include_versions = True  # Jeśli True, dodaje wersje bibliotek

# Znajdowanie bibliotek
libraries = find_imports_in_folder(folder_path)

# Pobieranie wersji bibliotek (jeśli ustawiono include_versions na True)
if include_versions:
    libraries_with_versions = get_library_versions(libraries)

# Zapisywanie wyników do requirements.txt
with open("requirements.txt", "w") as f:
    for library in sorted(libraries):
        if include_versions:
            version = libraries_with_versions.get(library)
            if version:
                f.write(f"{library}=={version}\n")
            else:
                f.write(f"{library}\n")  # Brak wersji, jeśli biblioteka nie jest zainstalowana
        else:
            f.write(f"{library}\n")

print("Plik requirements.txt został wygenerowany.")
