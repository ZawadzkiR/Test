import git
import os
import ipywidgets as widgets
from IPython.display import display


# Funkcja sprawdzająca, czy repozytorium jest aktualne
def check_repo_status():
    try:
        repo = git.Repo(search_parent_directories=True)
        origin = repo.remotes.origin
        origin.fetch()  # Pobranie aktualnych danych z repo
        status = repo.git.status('-uno')  # Sprawdzenie statusu repo
        if 'up to date' in status:
            return 'up_to_date'
        else:
            return 'update_available'
    except git.exc.InvalidGitRepositoryError:
        print("Brak repozytorium Git w tym katalogu.")
        return 'error'


# Funkcja inicjująca submoduł
def init_submodule():
    try:
        repo = git.Repo(search_parent_directories=True)
        submodule_path = os.path.join(repo.working_dir, 'modules/RepozytoriumA')
        
        # Sprawdzenie, czy submoduł już istnieje
        if not os.path.exists(submodule_path):
            repo.git.execute([
                'git', 'submodule', 'add',
                'https://bitbucket.org/user/RepozytoriumA.git',
                'modules/RepozytoriumA'
            ])
            repo.git.execute(['git', 'submodule', 'update', '--init', '--recursive'])

            # Ustawienie sparse-checkout na pusty stan
            set_sparse_checkout([])
            print("RepozytoriumA dodane jako submoduł z pustym sparse-checkout.")
        else:
            print("RepozytoriumA jest już submodułem.")
        
        # Aktualizacja checkboxów na podstawie sparsowanych katalogów
        update_checkboxes()
    except git.exc.InvalidGitRepositoryError:
        print("Brak repozytorium Git w tym katalogu.")


# Funkcja aktualizująca submoduł
def update_submodule():
    try:
        repo = git.Repo(search_parent_directories=True)
        submodule = repo.submodules['RepozytoriumA']
        submodule.update(init=True, recursive=True)
        print("Submoduł zaktualizowany.")
    except git.exc.InvalidGitRepositoryError:
        print("Brak repozytorium Git w tym katalogu.")


# Funkcja do ustawienia sparse-checkout
def set_sparse_checkout(folders):
    try:
        repo = git.Repo(search_parent_directories=True)
        submodule = repo.submodules['RepozytoriumA']
        submodule_repo = submodule.module()

        # Ustawienie sparse-checkout
        submodule_repo.git.config('core.sparseCheckout', 'true')
        submodule_repo.git.execute(['git', 'sparse-checkout', 'set', *folders])

        submodule_repo.git.checkout('master')  # Przełączamy się na mastera
        submodule_repo.git.pull()  # Pobieramy zmiany
        print(f"Sparse-checkout ustawiony dla katalogów: {', '.join(folders)}")
    except git.exc.InvalidGitRepositoryError:
        print("Brak repozytorium Git w tym katalogu.")


# Funkcja odczytująca sparsowane katalogi
def get_sparse_checkout_folders():
    try:
        repo = git.Repo(search_parent_directories=True)
        submodule = repo.submodules['RepozytoriumA']
        submodule_repo = submodule.module()

        # Pobieranie sparsowanych katalogów
        sparse_folders = submodule_repo.git.execute(['git', 'sparse-checkout', 'list']).splitlines()
        return [folder.strip() for folder in sparse_folders]
    except git.exc.InvalidGitRepositoryError:
        print("Brak repozytorium Git w tym katalogu.")
        return []


# Funkcja aktualizująca checkboxy na podstawie sparsowanych katalogów
def update_checkboxes():
    sparse_folders = get_sparse_checkout_folders()

    folder_x.value = 'X' in sparse_folders
    folder_y.value = 'Y' in sparse_folders
    folder_z.value = 'Z' in sparse_folders


# Interfejs użytkownika
menu_button = widgets.Button(description="Zainicjuj RepozytoriumA", disabled=False)
update_button = widgets.Button(description="Sprawdź aktualność", disabled=False)

folder_x = widgets.Checkbox(value=False, description="X")
folder_y = widgets.Checkbox(value=False, description="Y")
folder_z = widgets.Checkbox(value=False, description="Z")

def on_init_button_click(b):
    init_submodule()

def on_update_button_click(b):
    status = check_repo_status()
    if status == 'up_to_date':
        update_button.style.button_color = 'lightgreen'
        update_button.description = "UP TO DATE"
    elif status == 'update_available':
        update_button.style.button_color = 'yellow'
        update_button.description = "UPDATE"
        update_submodule()

def on_folder_change(change):
    selected_folders = []
    if folder_x.value:
        selected_folders.append('X')
    if folder_y.value:
        selected_folders.append('Y')
    if folder_z.value:
        selected_folders.append('Z')
    set_sparse_checkout(selected_folders)

menu_button.on_click(on_init_button_click)
update_button.on_click(on_update_button_click)
folder_x.observe(on_folder_change, names='value')
folder_y.observe(on_folder_change, names='value')
folder_z.observe(on_folder_change, names='value')

# Wyświetlenie UI
display(menu_button, update_button, folder_x, folder_y, folder_z)

# Aktualizacja checkboxów na starcie
update_checkboxes()
